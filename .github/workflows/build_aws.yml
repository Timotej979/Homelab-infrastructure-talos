name: Build AWS Image

permissions:
  contents: 'read'
  id-token: 'write'  # Required for workload identity provider OIDC token

on:
  workflow_call:
  workflow_dispatch:

env:
  HCP_CLI_VERSION: "0.10.0"
  PACKER_VERSION: "1.14.2"

jobs:
  dev-arm64:
    name: Build Development AWS Image for ARM64 architecture
    environment: Development
    runs-on: ubuntu-24.04
    if: github.ref_name == 'dev'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure HCP Credentials
        id: hcp-auth
        uses: hashicorp/hcp-auth-action@v0.1.0
        with:
          workload_identity_provider: ${{ secrets.HCP_WIP_AWS_AZURE_GCP }}
          export_environment_variables: true

      - name: Install HCP CLI
        uses: hashicorp/hcp-setup-action@v0.1.0
        with:
          version: ${{ env.HCP_CLI_VERSION }}

      - name: Install Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Configure AWS Credentials
        id: aws-configure-credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          output-env-credentials: true

      - name: Check AWS Cloud environment access
        run: |
          aws sts get-caller-identity

      - name: Build Development Image
        env:
          HCP_CRED_FILE: ${{ steps.hcp-auth.outputs.credentials_file_path }}
        working-directory: ./packer/aws/templates
        run: |
          GREEN='\033[38;5;82m'
          ORANGE='\033[38;5;208m'
          RED='\033[38;5;196m'
          RESET='\033[0m'

          log_success() { printf "${GREEN}[SUCCESS] %s${RESET}\n\n" "$1"; }
          log_warning() { printf "${ORANGE}[WARNING] %s${RESET}\n" "$1"; }
          log_error() { printf "${RED}[ERROR] %s${RESET}\n" "$1"; }
          log_info() { printf "[INFO] %s\n" "$1"; }

          log_info "Logging in to HCP..."
          hcp auth login --cred-file=$HCP_CRED_FILE
          log_success "Logged in to HCP successfully."

          log_info "Export HCP_CRED_FILE env var for packer to use..."
          export HCP_CRED_FILE=$HCP_CRED_FILE
          log_success "HCP_CRED_FILE env var exported successfully."

          log_info "Initializing Packer build..."
          packer init ./aws.pkr.hcl
          log_success "Packer build initialized successfully."

          log_info "Starting Packer build..."
          PACKER_OUTPUT=$(packer build \
            -var "channel=aws-dev-arm64" \
            -var "aws_instance_type=t4g.medium" \
            -var "talos_version=latest" \
            -var "talos_architecture=arm64" \
            -var "talos_extensions=[]" \
            ./aws.pkr.hcl 2>&1)
          PACKER_EXIT_CODE=$?
          
          echo "$PACKER_OUTPUT"
          
          if [ $PACKER_EXIT_CODE -ne 0 ]; then
            log_error "Packer build failed with exit code $PACKER_EXIT_CODE"
            exit $PACKER_EXIT_CODE
          fi
          
          # Extract iteration ID from Packer output (the version fingerprint)
          ITERATION_ID=$(echo "$PACKER_OUTPUT" | grep -o 'versions/[^[:space:]]*' | sed 's|versions/||' | head -1)
          
          if [ -z "$ITERATION_ID" ]; then
            log_error "Failed to extract iteration ID from Packer output"
            exit 1
          fi
          
          log_success "AWS image built successfully. Iteration ID: $ITERATION_ID"
          
          log_info "Promoting image to aws-dev-arm64 channel..."
          
          # Get HCP access token using workload identity provider
          # Use GitHub Actions OIDC token with workload identity provider URL
          log_info "Obtaining HCP access token via workload identity provider..."
          
          # Get workload identity provider URL from credential file
          WIP_URL=$(jq -r '.workload.url // empty' "$HCP_CRED_FILE" 2>/dev/null)
          
          if [ -z "$WIP_URL" ] || [ "$WIP_URL" = "null" ]; then
            log_error "Failed to extract workload identity provider URL from credential file"
            log_error "Credential file keys: $(jq -r 'keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse JSON')"
            log_error "Workload structure: $(jq '.workload | keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse')"
            exit 1
          fi
          
          # Get GitHub Actions OIDC token (must be requested - not automatically available)
          # GitHub provides ACTIONS_ID_TOKEN_REQUEST_TOKEN and ACTIONS_ID_TOKEN_REQUEST_URL when id-token: write permission is set
          log_info "Requesting GitHub OIDC token..."
          # Append audience parameter (use ? if URL has no query params, & if it does)
          if [[ "$ACTIONS_ID_TOKEN_REQUEST_URL" == *"?"* ]]; then
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://auth.hashicorp.com"
          else
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}?audience=https://auth.hashicorp.com"
          fi
          GITHUB_OIDC_TOKEN=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$OIDC_REQUEST_URL" | jq -r '.value // empty' 2>/dev/null)
          
          if [ -z "$GITHUB_OIDC_TOKEN" ] || [ "$GITHUB_OIDC_TOKEN" = "null" ]; then
            log_error "Failed to obtain GitHub OIDC token"
            log_error "ACTIONS_ID_TOKEN_REQUEST_TOKEN is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ] && echo 'yes' || echo 'no')"
            log_error "ACTIONS_ID_TOKEN_REQUEST_URL is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_URL" ] && echo 'yes' || echo 'no')"
            exit 1
          fi
          
          # Exchange GitHub OIDC token for HCP access token using workload identity provider
          log_info "Exchanging GitHub OIDC token for HCP access token via workload identity provider..."
          log_info "Workload identity provider URL: $WIP_URL"
          
          TOKEN_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$WIP_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
            -d "subject_token=$GITHUB_OIDC_TOKEN" \
            -d "subject_token_type=urn:ietf:params:oauth:token-type:jwt" \
            -d "requested_token_type=urn:ietf:params:oauth:token-type:access_token" 2>&1)
          
          HTTP_CODE=$(echo "$TOKEN_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$TOKEN_RESPONSE" | sed '$d')
          
          if [ -z "$HTTP_CODE" ] || [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            log_error "Token exchange failed with HTTP $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          HCP_ACCESS_TOKEN=$(echo "$RESPONSE_BODY" | jq -r '.access_token // empty' 2>/dev/null)
          
          if [ -z "$HCP_ACCESS_TOKEN" ] || [ "$HCP_ACCESS_TOKEN" = "null" ]; then
            log_error "Failed to extract access_token from token exchange response"
            log_error "HTTP Code: $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          log_info "Successfully obtained HCP access token"
          
          # Get organization ID using HCP CLI (service principals can list their orgs)
          ORG_JSON_OUTPUT=$(hcp organizations list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp organizations list'"
            log_error "Command output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_ORG_ID=$(echo "$ORG_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_ORG_ID" ] || [ "$HCP_ORG_ID" = "null" ]; then
            log_error "Failed to extract organization ID from 'hcp organizations list --format=json'."
            log_error "Raw JSON output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Org ID and Project ID are identifiers, not secrets - safe to log for debugging
          log_info "Organization ID: $HCP_ORG_ID"
          
          # Get project ID using HCP CLI (service principal context already has org set, so this works directly)
          PROJECT_JSON_OUTPUT=$(hcp projects list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp projects list'"
            log_error "Command output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_PROJECT_ID=$(echo "$PROJECT_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_PROJECT_ID" ] || [ "$HCP_PROJECT_ID" = "null" ]; then
            log_error "Failed to extract project ID from 'hcp projects list --format=json'."
            log_error "Raw JSON output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          log_info "Project ID: $HCP_PROJECT_ID"
          
          # Assign iteration to channel via HCP Packer API (PATCH method per API spec)
          # Endpoint: /organizations/{org_id}/projects/{project_id}/images/{bucket_name}/channels/{channel_name}
          HCP_BASE_URL="https://api.cloud.hashicorp.com/packer/2021-04-30"
          CHANNEL_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
            "${HCP_BASE_URL}/organizations/${HCP_ORG_ID}/projects/${HCP_PROJECT_ID}/images/homelab-infrastructure-talos/channels/aws-dev-arm64" \
            --header "Authorization: Bearer ${HCP_ACCESS_TOKEN}" \
            --header "Content-Type: application/json" \
            --data "{\"iteration_id\": \"$ITERATION_ID\"}")
          
          HTTP_CODE=$(echo "$CHANNEL_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$CHANNEL_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "204" ]; then
            log_error "Failed to assign iteration to channel. HTTP $HTTP_CODE: $RESPONSE_BODY"
            exit 1
          fi
          
          log_success "Image promoted to aws-dev-arm64 channel."

  dev-amd64:
    name: Build Development AWS Image for AMD64 architecture
    environment: Development
    runs-on: ubuntu-24.04
    if: github.ref_name == 'dev'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure HCP Credentials
        id: hcp-auth
        uses: hashicorp/hcp-auth-action@v0.1.0
        with:
          workload_identity_provider: ${{ secrets.HCP_WIP_AWS_AZURE_GCP }}
          export_environment_variables: true

      - name: Install HCP CLI
        uses: hashicorp/hcp-setup-action@v0.1.0
        with:
          version: ${{ env.HCP_CLI_VERSION }}

      - name: Install Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Configure AWS Credentials
        id: aws-configure-credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          output-env-credentials: true

      - name: Check AWS Cloud environment access
        run: |
          aws sts get-caller-identity

      - name: Build Development Image
        env:
          HCP_CRED_FILE: ${{ steps.hcp-auth.outputs.credentials_file_path }}
        working-directory: ./packer/aws/templates
        run: |
          GREEN='\033[38;5;82m'
          ORANGE='\033[38;5;208m'
          RED='\033[38;5;196m'
          RESET='\033[0m'

          log_success() { printf "${GREEN}[SUCCESS] %s${RESET}\n\n" "$1"; }
          log_warning() { printf "${ORANGE}[WARNING] %s${RESET}\n" "$1"; }
          log_error() { printf "${RED}[ERROR] %s${RESET}\n" "$1"; }
          log_info() { printf "[INFO] %s\n" "$1"; }

          log_info "Logging in to HCP..."
          hcp auth login --cred-file=$HCP_CRED_FILE
          log_success "Logged in to HCP successfully."

          log_info "Export HCP_CRED_FILE env var for packer to use..."
          export HCP_CRED_FILE=$HCP_CRED_FILE
          log_success "HCP_CRED_FILE env var exported successfully."

          log_info "Initializing Packer build..."
          packer init ./aws.pkr.hcl
          log_success "Packer build initialized successfully."

          log_info "Starting Packer build..."
          PACKER_OUTPUT=$(packer build \
            -var "channel=aws-dev-amd64" \
            -var "aws_instance_type=t3a.medium" \
            -var "talos_version=latest" \
            -var "talos_architecture=amd64" \
            -var "talos_extensions=[]" \
            ./aws.pkr.hcl 2>&1)
          
          echo "$PACKER_OUTPUT"
          
          # Extract iteration ID from Packer output (the version fingerprint)
          ITERATION_ID=$(echo "$PACKER_OUTPUT" | grep -o 'versions/[^[:space:]]*' | sed 's|versions/||' | head -1)
          
          if [ -z "$ITERATION_ID" ]; then
            log_error "Failed to extract iteration ID from Packer output"
            exit 1
          fi
          
          log_success "AWS image built successfully. Iteration ID: $ITERATION_ID"
          
          log_info "Promoting image to aws-dev-amd64 channel..."
          
          # Get HCP access token using workload identity provider
          # Use GitHub Actions OIDC token with workload identity provider URL
          log_info "Obtaining HCP access token via workload identity provider..."
          
          # Get workload identity provider URL from credential file
          WIP_URL=$(jq -r '.workload.url // empty' "$HCP_CRED_FILE" 2>/dev/null)
          
          if [ -z "$WIP_URL" ] || [ "$WIP_URL" = "null" ]; then
            log_error "Failed to extract workload identity provider URL from credential file"
            log_error "Credential file keys: $(jq -r 'keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse JSON')"
            log_error "Workload structure: $(jq '.workload | keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse')"
            exit 1
          fi
          
          # Get GitHub Actions OIDC token (must be requested - not automatically available)
          # GitHub provides ACTIONS_ID_TOKEN_REQUEST_TOKEN and ACTIONS_ID_TOKEN_REQUEST_URL when id-token: write permission is set
          log_info "Requesting GitHub OIDC token..."
          # Append audience parameter (use ? if URL has no query params, & if it does)
          if [[ "$ACTIONS_ID_TOKEN_REQUEST_URL" == *"?"* ]]; then
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://auth.hashicorp.com"
          else
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}?audience=https://auth.hashicorp.com"
          fi
          GITHUB_OIDC_TOKEN=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$OIDC_REQUEST_URL" | jq -r '.value // empty' 2>/dev/null)
          
          if [ -z "$GITHUB_OIDC_TOKEN" ] || [ "$GITHUB_OIDC_TOKEN" = "null" ]; then
            log_error "Failed to obtain GitHub OIDC token"
            log_error "ACTIONS_ID_TOKEN_REQUEST_TOKEN is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ] && echo 'yes' || echo 'no')"
            log_error "ACTIONS_ID_TOKEN_REQUEST_URL is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_URL" ] && echo 'yes' || echo 'no')"
            exit 1
          fi
          
          # Exchange GitHub OIDC token for HCP access token using workload identity provider
          log_info "Exchanging GitHub OIDC token for HCP access token via workload identity provider..."
          log_info "Workload identity provider URL: $WIP_URL"
          
          TOKEN_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$WIP_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
            -d "subject_token=$GITHUB_OIDC_TOKEN" \
            -d "subject_token_type=urn:ietf:params:oauth:token-type:jwt" \
            -d "requested_token_type=urn:ietf:params:oauth:token-type:access_token" 2>&1)
          
          HTTP_CODE=$(echo "$TOKEN_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$TOKEN_RESPONSE" | sed '$d')
          
          if [ -z "$HTTP_CODE" ] || [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            log_error "Token exchange failed with HTTP $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          HCP_ACCESS_TOKEN=$(echo "$RESPONSE_BODY" | jq -r '.access_token // empty' 2>/dev/null)
          
          if [ -z "$HCP_ACCESS_TOKEN" ] || [ "$HCP_ACCESS_TOKEN" = "null" ]; then
            log_error "Failed to extract access_token from token exchange response"
            log_error "HTTP Code: $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          log_info "Successfully obtained HCP access token"
          
          # Get organization ID using HCP CLI (service principals can list their orgs)
          ORG_JSON_OUTPUT=$(hcp organizations list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp organizations list'"
            log_error "Command output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_ORG_ID=$(echo "$ORG_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_ORG_ID" ] || [ "$HCP_ORG_ID" = "null" ]; then
            log_error "Failed to extract organization ID from 'hcp organizations list --format=json'."
            log_error "Raw JSON output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Org ID and Project ID are identifiers, not secrets - safe to log for debugging
          log_info "Organization ID: $HCP_ORG_ID"
          
          # Get project ID using HCP CLI (service principal context already has org set, so this works directly)
          PROJECT_JSON_OUTPUT=$(hcp projects list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp projects list'"
            log_error "Command output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_PROJECT_ID=$(echo "$PROJECT_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_PROJECT_ID" ] || [ "$HCP_PROJECT_ID" = "null" ]; then
            log_error "Failed to extract project ID from 'hcp projects list --format=json'."
            log_error "Raw JSON output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          log_info "Project ID: $HCP_PROJECT_ID"
          
          # Assign iteration to channel via HCP Packer API (PATCH method per API spec)
          # Endpoint: /organizations/{org_id}/projects/{project_id}/images/{bucket_name}/channels/{channel_name}
          HCP_BASE_URL="https://api.cloud.hashicorp.com/packer/2021-04-30"
          CHANNEL_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
            "${HCP_BASE_URL}/organizations/${HCP_ORG_ID}/projects/${HCP_PROJECT_ID}/images/homelab-infrastructure-talos/channels/aws-dev-amd64" \
            --header "Authorization: Bearer ${HCP_ACCESS_TOKEN}" \
            --header "Content-Type: application/json" \
            --data "{\"iteration_id\": \"$ITERATION_ID\"}")
          
          HTTP_CODE=$(echo "$CHANNEL_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$CHANNEL_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "204" ]; then
            log_error "Failed to assign iteration to channel. HTTP $HTTP_CODE: $RESPONSE_BODY"
            exit 1
          fi
          
          log_success "Image promoted to aws-dev-amd64 channel."

  stage-arm64:
    name: Build Staging AWS Image for ARM64 architecture
    environment: Staging
    runs-on: ubuntu-24.04
    if: github.ref_name == 'stage'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure HCP Credentials
        id: hcp-auth
        uses: hashicorp/hcp-auth-action@v0.1.0
        with:
          workload_identity_provider: ${{ secrets.HCP_WIP_AWS_AZURE_GCP }}
          export_environment_variables: true

      - name: Install HCP CLI
        uses: hashicorp/hcp-setup-action@v0.1.0
        with:
          version: ${{ env.HCP_CLI_VERSION }}

      - name: Install Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Configure AWS Credentials
        id: aws-configure-credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0
        env:
          ACTIONS_STEP_DEBUG: true
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          output-env-credentials: true

      - name: Check AWS Cloud environment access
        run: |
          aws sts get-caller-identity

      - name: Build Staging Image
        env:
          HCP_CRED_FILE: ${{ steps.hcp-auth.outputs.credentials_file_path }}
        working-directory: ./packer/aws/templates
        run: |
          GREEN='\033[38;5;82m'
          ORANGE='\033[38;5;208m'
          RED='\033[38;5;196m'
          RESET='\033[0m'

          log_success() { printf "${GREEN}[SUCCESS] %s${RESET}\n\n" "$1"; }
          log_warning() { printf "${ORANGE}[WARNING] %s${RESET}\n" "$1"; }
          log_error() { printf "${RED}[ERROR] %s${RESET}\n" "$1"; }
          log_info() { printf "[INFO] %s\n" "$1"; }

          log_info "Logging in to HCP..."
          hcp auth login --cred-file=$HCP_CRED_FILE
          log_success "Logged in to HCP successfully."

          log_info "Export HCP_CRED_FILE env var for packer to use..."
          export HCP_CRED_FILE=$HCP_CRED_FILE
          log_success "HCP_CRED_FILE env var exported successfully."

          log_info "Initializing Packer build..."
          packer init ./aws.pkr.hcl
          log_success "Packer build initialized successfully."

          log_info "Starting Packer build..."
          PACKER_OUTPUT=$(packer build \
            -var "channel=aws-stage-arm64" \
            -var "aws_instance_type=t4g.medium" \
            -var "talos_version=latest" \
            -var "talos_architecture=arm64" \
            -var "talos_extensions=[]" \
            ./aws.pkr.hcl 2>&1)
          
          echo "$PACKER_OUTPUT"
          
          # Extract iteration ID from Packer output (the version fingerprint)
          ITERATION_ID=$(echo "$PACKER_OUTPUT" | grep -o 'versions/[^[:space:]]*' | sed 's|versions/||' | head -1)
          
          if [ -z "$ITERATION_ID" ]; then
            log_error "Failed to extract iteration ID from Packer output"
            exit 1
          fi
          
          log_success "AWS image built successfully. Iteration ID: $ITERATION_ID"
          
          log_info "Promoting image to aws-stage-arm64 channel..."
          
          # Get HCP access token using workload identity provider
          # Use GitHub Actions OIDC token with workload identity provider URL
          log_info "Obtaining HCP access token via workload identity provider..."
          
          # Get workload identity provider URL from credential file
          WIP_URL=$(jq -r '.workload.url // empty' "$HCP_CRED_FILE" 2>/dev/null)
          
          if [ -z "$WIP_URL" ] || [ "$WIP_URL" = "null" ]; then
            log_error "Failed to extract workload identity provider URL from credential file"
            log_error "Credential file keys: $(jq -r 'keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse JSON')"
            log_error "Workload structure: $(jq '.workload | keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse')"
            exit 1
          fi
          
          # Get GitHub Actions OIDC token (must be requested - not automatically available)
          # GitHub provides ACTIONS_ID_TOKEN_REQUEST_TOKEN and ACTIONS_ID_TOKEN_REQUEST_URL when id-token: write permission is set
          log_info "Requesting GitHub OIDC token..."
          # Append audience parameter (use ? if URL has no query params, & if it does)
          if [[ "$ACTIONS_ID_TOKEN_REQUEST_URL" == *"?"* ]]; then
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://auth.hashicorp.com"
          else
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}?audience=https://auth.hashicorp.com"
          fi
          GITHUB_OIDC_TOKEN=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$OIDC_REQUEST_URL" | jq -r '.value // empty' 2>/dev/null)
          
          if [ -z "$GITHUB_OIDC_TOKEN" ] || [ "$GITHUB_OIDC_TOKEN" = "null" ]; then
            log_error "Failed to obtain GitHub OIDC token"
            log_error "ACTIONS_ID_TOKEN_REQUEST_TOKEN is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ] && echo 'yes' || echo 'no')"
            log_error "ACTIONS_ID_TOKEN_REQUEST_URL is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_URL" ] && echo 'yes' || echo 'no')"
            exit 1
          fi
          
          # Exchange GitHub OIDC token for HCP access token using workload identity provider
          log_info "Exchanging GitHub OIDC token for HCP access token via workload identity provider..."
          log_info "Workload identity provider URL: $WIP_URL"
          
          TOKEN_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$WIP_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
            -d "subject_token=$GITHUB_OIDC_TOKEN" \
            -d "subject_token_type=urn:ietf:params:oauth:token-type:jwt" \
            -d "requested_token_type=urn:ietf:params:oauth:token-type:access_token" 2>&1)
          
          HTTP_CODE=$(echo "$TOKEN_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$TOKEN_RESPONSE" | sed '$d')
          
          if [ -z "$HTTP_CODE" ] || [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            log_error "Token exchange failed with HTTP $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          HCP_ACCESS_TOKEN=$(echo "$RESPONSE_BODY" | jq -r '.access_token // empty' 2>/dev/null)
          
          if [ -z "$HCP_ACCESS_TOKEN" ] || [ "$HCP_ACCESS_TOKEN" = "null" ]; then
            log_error "Failed to extract access_token from token exchange response"
            log_error "HTTP Code: $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          log_info "Successfully obtained HCP access token"
          
          # Get organization ID using HCP CLI (service principals can list their orgs)
          ORG_JSON_OUTPUT=$(hcp organizations list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp organizations list'"
            log_error "Command output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_ORG_ID=$(echo "$ORG_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_ORG_ID" ] || [ "$HCP_ORG_ID" = "null" ]; then
            log_error "Failed to extract organization ID from 'hcp organizations list --format=json'."
            log_error "Raw JSON output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Org ID and Project ID are identifiers, not secrets - safe to log for debugging
          log_info "Organization ID: $HCP_ORG_ID"
          
          # Get project ID using HCP CLI (service principal context already has org set, so this works directly)
          PROJECT_JSON_OUTPUT=$(hcp projects list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp projects list'"
            log_error "Command output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_PROJECT_ID=$(echo "$PROJECT_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_PROJECT_ID" ] || [ "$HCP_PROJECT_ID" = "null" ]; then
            log_error "Failed to extract project ID from 'hcp projects list --format=json'."
            log_error "Raw JSON output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          log_info "Project ID: $HCP_PROJECT_ID"
          
          # Assign iteration to channel via HCP Packer API (PATCH method per API spec)
          # Endpoint: /organizations/{org_id}/projects/{project_id}/images/{bucket_name}/channels/{channel_name}
          HCP_BASE_URL="https://api.cloud.hashicorp.com/packer/2021-04-30"
          CHANNEL_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
            "${HCP_BASE_URL}/organizations/${HCP_ORG_ID}/projects/${HCP_PROJECT_ID}/images/homelab-infrastructure-talos/channels/aws-stage-arm64" \
            --header "Authorization: Bearer ${HCP_ACCESS_TOKEN}" \
            --header "Content-Type: application/json" \
            --data "{\"iteration_id\": \"$ITERATION_ID\"}")
          
          HTTP_CODE=$(echo "$CHANNEL_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$CHANNEL_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "204" ]; then
            log_error "Failed to assign iteration to channel. HTTP $HTTP_CODE: $RESPONSE_BODY"
            exit 1
          fi
          
          log_success "Image promoted to aws-stage-arm64 channel."

  stage-amd64:
    name: Build Staging AWS Image for AMD64 architecture
    environment: Staging
    runs-on: ubuntu-24.04
    if: github.ref_name == 'stage'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure HCP Credentials
        id: hcp-auth
        uses: hashicorp/hcp-auth-action@v0.1.0
        with:
          workload_identity_provider: ${{ secrets.HCP_WIP_AWS_AZURE_GCP }}
          export_environment_variables: true

      - name: Install HCP CLI
        uses: hashicorp/hcp-setup-action@v0.1.0
        with:
          version: ${{ env.HCP_CLI_VERSION }}

      - name: Install Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Configure AWS Credentials
        id: aws-configure-credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0
        env:
          ACTIONS_STEP_DEBUG: true
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          output-env-credentials: true

      - name: Check AWS Cloud environment access
        run: |
          aws sts get-caller-identity

      - name: Build Staging Image
        env:
          HCP_CRED_FILE: ${{ steps.hcp-auth.outputs.credentials_file_path }}
        working-directory: ./packer/aws/templates
        run: |
          GREEN='\033[38;5;82m'
          ORANGE='\033[38;5;208m'
          RED='\033[38;5;196m'
          RESET='\033[0m'

          log_success() { printf "${GREEN}[SUCCESS] %s${RESET}\n\n" "$1"; }
          log_warning() { printf "${ORANGE}[WARNING] %s${RESET}\n" "$1"; }
          log_error() { printf "${RED}[ERROR] %s${RESET}\n" "$1"; }
          log_info() { printf "[INFO] %s\n" "$1"; }

          log_info "Logging in to HCP..."
          hcp auth login --cred-file=$HCP_CRED_FILE
          log_success "Logged in to HCP successfully."

          log_info "Export HCP_CRED_FILE env var for packer to use..."
          export HCP_CRED_FILE=$HCP_CRED_FILE
          log_success "HCP_CRED_FILE env var exported successfully."

          log_info "Initializing Packer build..."
          packer init ./aws.pkr.hcl
          log_success "Packer build initialized successfully."

          log_info "Starting Packer build..."
          PACKER_OUTPUT=$(packer build \
            -var "channel=aws-stage-amd64" \
            -var "aws_instance_type=t3a.medium" \
            -var "talos_version=latest" \
            -var "talos_architecture=amd64" \
            -var "talos_extensions=[]" \
            ./aws.pkr.hcl 2>&1)
          
          echo "$PACKER_OUTPUT"
          
          # Extract iteration ID from Packer output (the version fingerprint)
          ITERATION_ID=$(echo "$PACKER_OUTPUT" | grep -o 'versions/[^[:space:]]*' | sed 's|versions/||' | head -1)
          
          if [ -z "$ITERATION_ID" ]; then
            log_error "Failed to extract iteration ID from Packer output"
            exit 1
          fi
          
          log_success "AWS image built successfully. Iteration ID: $ITERATION_ID"
          
          log_info "Promoting image to aws-stage-amd64 channel..."
          
          # Get HCP access token using workload identity provider
          # Use GitHub Actions OIDC token with workload identity provider URL
          log_info "Obtaining HCP access token via workload identity provider..."
          
          # Get workload identity provider URL from credential file
          WIP_URL=$(jq -r '.workload.url // empty' "$HCP_CRED_FILE" 2>/dev/null)
          
          if [ -z "$WIP_URL" ] || [ "$WIP_URL" = "null" ]; then
            log_error "Failed to extract workload identity provider URL from credential file"
            log_error "Credential file keys: $(jq -r 'keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse JSON')"
            log_error "Workload structure: $(jq '.workload | keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse')"
            exit 1
          fi
          
          # Get GitHub Actions OIDC token (must be requested - not automatically available)
          # GitHub provides ACTIONS_ID_TOKEN_REQUEST_TOKEN and ACTIONS_ID_TOKEN_REQUEST_URL when id-token: write permission is set
          log_info "Requesting GitHub OIDC token..."
          # Append audience parameter (use ? if URL has no query params, & if it does)
          if [[ "$ACTIONS_ID_TOKEN_REQUEST_URL" == *"?"* ]]; then
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://auth.hashicorp.com"
          else
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}?audience=https://auth.hashicorp.com"
          fi
          GITHUB_OIDC_TOKEN=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$OIDC_REQUEST_URL" | jq -r '.value // empty' 2>/dev/null)
          
          if [ -z "$GITHUB_OIDC_TOKEN" ] || [ "$GITHUB_OIDC_TOKEN" = "null" ]; then
            log_error "Failed to obtain GitHub OIDC token"
            log_error "ACTIONS_ID_TOKEN_REQUEST_TOKEN is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ] && echo 'yes' || echo 'no')"
            log_error "ACTIONS_ID_TOKEN_REQUEST_URL is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_URL" ] && echo 'yes' || echo 'no')"
            exit 1
          fi
          
          # Exchange GitHub OIDC token for HCP access token using workload identity provider
          log_info "Exchanging GitHub OIDC token for HCP access token via workload identity provider..."
          log_info "Workload identity provider URL: $WIP_URL"
          
          TOKEN_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$WIP_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
            -d "subject_token=$GITHUB_OIDC_TOKEN" \
            -d "subject_token_type=urn:ietf:params:oauth:token-type:jwt" \
            -d "requested_token_type=urn:ietf:params:oauth:token-type:access_token" 2>&1)
          
          HTTP_CODE=$(echo "$TOKEN_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$TOKEN_RESPONSE" | sed '$d')
          
          if [ -z "$HTTP_CODE" ] || [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            log_error "Token exchange failed with HTTP $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          HCP_ACCESS_TOKEN=$(echo "$RESPONSE_BODY" | jq -r '.access_token // empty' 2>/dev/null)
          
          if [ -z "$HCP_ACCESS_TOKEN" ] || [ "$HCP_ACCESS_TOKEN" = "null" ]; then
            log_error "Failed to extract access_token from token exchange response"
            log_error "HTTP Code: $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          log_info "Successfully obtained HCP access token"
          
          # Get organization ID using HCP CLI (service principals can list their orgs)
          ORG_JSON_OUTPUT=$(hcp organizations list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp organizations list'"
            log_error "Command output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_ORG_ID=$(echo "$ORG_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_ORG_ID" ] || [ "$HCP_ORG_ID" = "null" ]; then
            log_error "Failed to extract organization ID from 'hcp organizations list --format=json'."
            log_error "Raw JSON output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Org ID and Project ID are identifiers, not secrets - safe to log for debugging
          log_info "Organization ID: $HCP_ORG_ID"
          
          # Get project ID using HCP CLI (service principal context already has org set, so this works directly)
          PROJECT_JSON_OUTPUT=$(hcp projects list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp projects list'"
            log_error "Command output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_PROJECT_ID=$(echo "$PROJECT_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_PROJECT_ID" ] || [ "$HCP_PROJECT_ID" = "null" ]; then
            log_error "Failed to extract project ID from 'hcp projects list --format=json'."
            log_error "Raw JSON output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          log_info "Project ID: $HCP_PROJECT_ID"
          
          # Assign iteration to channel via HCP Packer API (PATCH method per API spec)
          # Endpoint: /organizations/{org_id}/projects/{project_id}/images/{bucket_name}/channels/{channel_name}
          HCP_BASE_URL="https://api.cloud.hashicorp.com/packer/2021-04-30"
          CHANNEL_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
            "${HCP_BASE_URL}/organizations/${HCP_ORG_ID}/projects/${HCP_PROJECT_ID}/images/homelab-infrastructure-talos/channels/aws-stage-amd64" \
            --header "Authorization: Bearer ${HCP_ACCESS_TOKEN}" \
            --header "Content-Type: application/json" \
            --data "{\"iteration_id\": \"$ITERATION_ID\"}")
          
          HTTP_CODE=$(echo "$CHANNEL_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$CHANNEL_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "204" ]; then
            log_error "Failed to assign iteration to channel. HTTP $HTTP_CODE: $RESPONSE_BODY"
            exit 1
          fi
          
          log_success "Image promoted to aws-stage-amd64 channel."

  prod-arm64:
    name: Build Production AWS Image for ARM64 architecture
    environment: Production
    runs-on: ubuntu-24.04
    if: github.ref_name == 'main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure HCP Credentials
        id: hcp-auth
        uses: hashicorp/hcp-auth-action@v0.1.0
        with:
          workload_identity_provider: ${{ secrets.HCP_WIP_AWS_AZURE_GCP }}
          export_environment_variables: true

      - name: Install HCP CLI
        uses: hashicorp/hcp-setup-action@v0.1.0
        with:
          version: ${{ env.HCP_CLI_VERSION }}

      - name: Install Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Configure AWS Credentials
        id: aws-configure-credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          output-env-credentials: true

      - name: Check AWS Cloud environment access
        run: |
          aws sts get-caller-identity

      - name: Build Production Image
        env:
          HCP_CRED_FILE: ${{ steps.hcp-auth.outputs.credentials_file_path }}
        working-directory: ./packer/aws/templates
        run: |
          GREEN='\033[38;5;82m'
          ORANGE='\033[38;5;208m'
          RED='\033[38;5;196m'
          RESET='\033[0m'

          log_success() { printf "${GREEN}[SUCCESS] %s${RESET}\n\n" "$1"; }
          log_warning() { printf "${ORANGE}[WARNING] %s${RESET}\n" "$1"; }
          log_error() { printf "${RED}[ERROR] %s${RESET}\n" "$1"; }
          log_info() { printf "[INFO] %s\n" "$1"; }

          log_info "Logging in to HCP..."
          hcp auth login --cred-file=$HCP_CRED_FILE
          log_success "Logged in to HCP successfully."

          log_info "Export HCP_CRED_FILE env var for packer to use..."
          export HCP_CRED_FILE=$HCP_CRED_FILE
          log_success "HCP_CRED_FILE env var exported successfully."

          log_info "Initializing Packer build..."
          packer init ./aws.pkr.hcl
          log_success "Packer build initialized successfully."

          log_info "Starting Packer build..."
          PACKER_OUTPUT=$(packer build \
            -var "channel=aws-prod-arm64" \
            -var "aws_instance_type=t4g.medium" \
            -var "talos_version=latest" \
            -var "talos_architecture=arm64" \
            -var "talos_extensions=[]" \
            ./aws.pkr.hcl 2>&1)
          
          echo "$PACKER_OUTPUT"
          
          # Extract iteration ID from Packer output (the version fingerprint)
          ITERATION_ID=$(echo "$PACKER_OUTPUT" | grep -o 'versions/[^[:space:]]*' | sed 's|versions/||' | head -1)
          
          if [ -z "$ITERATION_ID" ]; then
            log_error "Failed to extract iteration ID from Packer output"
            exit 1
          fi
          
          log_success "AWS image built successfully. Iteration ID: $ITERATION_ID"
          
          log_info "Promoting image to aws-prod-arm64 channel..."
          
          # Get HCP access token using workload identity provider
          # Use GitHub Actions OIDC token with workload identity provider URL
          log_info "Obtaining HCP access token via workload identity provider..."
          
          # Get workload identity provider URL from credential file
          WIP_URL=$(jq -r '.workload.url // empty' "$HCP_CRED_FILE" 2>/dev/null)
          
          if [ -z "$WIP_URL" ] || [ "$WIP_URL" = "null" ]; then
            log_error "Failed to extract workload identity provider URL from credential file"
            log_error "Credential file keys: $(jq -r 'keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse JSON')"
            log_error "Workload structure: $(jq '.workload | keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse')"
            exit 1
          fi
          
          # Get GitHub Actions OIDC token (must be requested - not automatically available)
          # GitHub provides ACTIONS_ID_TOKEN_REQUEST_TOKEN and ACTIONS_ID_TOKEN_REQUEST_URL when id-token: write permission is set
          log_info "Requesting GitHub OIDC token..."
          # Append audience parameter (use ? if URL has no query params, & if it does)
          if [[ "$ACTIONS_ID_TOKEN_REQUEST_URL" == *"?"* ]]; then
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://auth.hashicorp.com"
          else
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}?audience=https://auth.hashicorp.com"
          fi
          GITHUB_OIDC_TOKEN=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$OIDC_REQUEST_URL" | jq -r '.value // empty' 2>/dev/null)
          
          if [ -z "$GITHUB_OIDC_TOKEN" ] || [ "$GITHUB_OIDC_TOKEN" = "null" ]; then
            log_error "Failed to obtain GitHub OIDC token"
            log_error "ACTIONS_ID_TOKEN_REQUEST_TOKEN is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ] && echo 'yes' || echo 'no')"
            log_error "ACTIONS_ID_TOKEN_REQUEST_URL is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_URL" ] && echo 'yes' || echo 'no')"
            exit 1
          fi
          
          # Exchange GitHub OIDC token for HCP access token using workload identity provider
          log_info "Exchanging GitHub OIDC token for HCP access token via workload identity provider..."
          log_info "Workload identity provider URL: $WIP_URL"
          
          TOKEN_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$WIP_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
            -d "subject_token=$GITHUB_OIDC_TOKEN" \
            -d "subject_token_type=urn:ietf:params:oauth:token-type:jwt" \
            -d "requested_token_type=urn:ietf:params:oauth:token-type:access_token" 2>&1)
          
          HTTP_CODE=$(echo "$TOKEN_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$TOKEN_RESPONSE" | sed '$d')
          
          if [ -z "$HTTP_CODE" ] || [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            log_error "Token exchange failed with HTTP $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          HCP_ACCESS_TOKEN=$(echo "$RESPONSE_BODY" | jq -r '.access_token // empty' 2>/dev/null)
          
          if [ -z "$HCP_ACCESS_TOKEN" ] || [ "$HCP_ACCESS_TOKEN" = "null" ]; then
            log_error "Failed to extract access_token from token exchange response"
            log_error "HTTP Code: $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          log_info "Successfully obtained HCP access token"
          
          # Get organization ID using HCP CLI (service principals can list their orgs)
          ORG_JSON_OUTPUT=$(hcp organizations list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp organizations list'"
            log_error "Command output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_ORG_ID=$(echo "$ORG_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_ORG_ID" ] || [ "$HCP_ORG_ID" = "null" ]; then
            log_error "Failed to extract organization ID from 'hcp organizations list --format=json'."
            log_error "Raw JSON output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Org ID and Project ID are identifiers, not secrets - safe to log for debugging
          log_info "Organization ID: $HCP_ORG_ID"
          
          # Get project ID using HCP CLI (service principal context already has org set, so this works directly)
          PROJECT_JSON_OUTPUT=$(hcp projects list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp projects list'"
            log_error "Command output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_PROJECT_ID=$(echo "$PROJECT_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_PROJECT_ID" ] || [ "$HCP_PROJECT_ID" = "null" ]; then
            log_error "Failed to extract project ID from 'hcp projects list --format=json'."
            log_error "Raw JSON output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          log_info "Project ID: $HCP_PROJECT_ID"
          
          # Assign iteration to channel via HCP Packer API (PATCH method per API spec)
          # Endpoint: /organizations/{org_id}/projects/{project_id}/images/{bucket_name}/channels/{channel_name}
          HCP_BASE_URL="https://api.cloud.hashicorp.com/packer/2021-04-30"
          CHANNEL_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
            "${HCP_BASE_URL}/organizations/${HCP_ORG_ID}/projects/${HCP_PROJECT_ID}/images/homelab-infrastructure-talos/channels/aws-prod-arm64" \
            --header "Authorization: Bearer ${HCP_ACCESS_TOKEN}" \
            --header "Content-Type: application/json" \
            --data "{\"iteration_id\": \"$ITERATION_ID\"}")
          
          HTTP_CODE=$(echo "$CHANNEL_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$CHANNEL_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "204" ]; then
            log_error "Failed to assign iteration to channel. HTTP $HTTP_CODE: $RESPONSE_BODY"
            exit 1
          fi
          
          log_success "Image promoted to aws-prod-arm64 channel."

  prod-amd64:
    name: Build Production AWS Image for AMD64 architecture
    environment: Production
    runs-on: ubuntu-24.04
    if: github.ref_name == 'main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure HCP Credentials
        id: hcp-auth
        uses: hashicorp/hcp-auth-action@v0.1.0
        with:
          workload_identity_provider: ${{ secrets.HCP_WIP_AWS_AZURE_GCP }}
          export_environment_variables: true

      - name: Install HCP CLI
        uses: hashicorp/hcp-setup-action@v0.1.0
        with:
          version: ${{ env.HCP_CLI_VERSION }}

      - name: Install Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Configure AWS Credentials
        id: aws-configure-credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          output-env-credentials: true

      - name: Check AWS Cloud environment access
        run: |
          aws sts get-caller-identity

      - name: Build Production Image
        env:
          HCP_CRED_FILE: ${{ steps.hcp-auth.outputs.credentials_file_path }}
        working-directory: ./packer/aws/templates
        run: |
          GREEN='\033[38;5;82m'
          ORANGE='\033[38;5;208m'
          RED='\033[38;5;196m'
          RESET='\033[0m'

          log_success() { printf "${GREEN}[SUCCESS] %s${RESET}\n\n" "$1"; }
          log_warning() { printf "${ORANGE}[WARNING] %s${RESET}\n" "$1"; }
          log_error() { printf "${RED}[ERROR] %s${RESET}\n" "$1"; }
          log_info() { printf "[INFO] %s\n" "$1"; }

          log_info "Logging in to HCP..."
          hcp auth login --cred-file=$HCP_CRED_FILE
          log_success "Logged in to HCP successfully."

          log_info "Export HCP_CRED_FILE env var for packer to use..."
          export HCP_CRED_FILE=$HCP_CRED_FILE
          log_success "HCP_CRED_FILE env var exported successfully."

          log_info "Initializing Packer build..."
          packer init ./aws.pkr.hcl
          log_success "Packer build initialized successfully."

          log_info "Starting Packer build..."
          PACKER_OUTPUT=$(packer build \
            -var "channel=aws-prod-amd64" \
            -var "aws_instance_type=t3a.medium" \
            -var "talos_version=latest" \
            -var "talos_architecture=amd64" \
            -var "talos_extensions=[]" \
            ./aws.pkr.hcl 2>&1)
          
          echo "$PACKER_OUTPUT"
          
          # Extract iteration ID from Packer output (the version fingerprint)
          ITERATION_ID=$(echo "$PACKER_OUTPUT" | grep -o 'versions/[^[:space:]]*' | sed 's|versions/||' | head -1)
          
          if [ -z "$ITERATION_ID" ]; then
            log_error "Failed to extract iteration ID from Packer output"
            exit 1
          fi
          
          log_success "AWS image built successfully. Iteration ID: $ITERATION_ID"
          
          log_info "Promoting image to aws-prod-amd64 channel..."
          
          # Get HCP access token using workload identity provider
          # Use GitHub Actions OIDC token with workload identity provider URL
          log_info "Obtaining HCP access token via workload identity provider..."
          
          # Get workload identity provider URL from credential file
          WIP_URL=$(jq -r '.workload.url // empty' "$HCP_CRED_FILE" 2>/dev/null)
          
          if [ -z "$WIP_URL" ] || [ "$WIP_URL" = "null" ]; then
            log_error "Failed to extract workload identity provider URL from credential file"
            log_error "Credential file keys: $(jq -r 'keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse JSON')"
            log_error "Workload structure: $(jq '.workload | keys | join(", ")' "$HCP_CRED_FILE" 2>/dev/null || echo 'Unable to parse')"
            exit 1
          fi
          
          # Get GitHub Actions OIDC token (must be requested - not automatically available)
          # GitHub provides ACTIONS_ID_TOKEN_REQUEST_TOKEN and ACTIONS_ID_TOKEN_REQUEST_URL when id-token: write permission is set
          log_info "Requesting GitHub OIDC token..."
          # Append audience parameter (use ? if URL has no query params, & if it does)
          if [[ "$ACTIONS_ID_TOKEN_REQUEST_URL" == *"?"* ]]; then
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://auth.hashicorp.com"
          else
            OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}?audience=https://auth.hashicorp.com"
          fi
          GITHUB_OIDC_TOKEN=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$OIDC_REQUEST_URL" | jq -r '.value // empty' 2>/dev/null)
          
          if [ -z "$GITHUB_OIDC_TOKEN" ] || [ "$GITHUB_OIDC_TOKEN" = "null" ]; then
            log_error "Failed to obtain GitHub OIDC token"
            log_error "ACTIONS_ID_TOKEN_REQUEST_TOKEN is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ] && echo 'yes' || echo 'no')"
            log_error "ACTIONS_ID_TOKEN_REQUEST_URL is set: $([ -n "$ACTIONS_ID_TOKEN_REQUEST_URL" ] && echo 'yes' || echo 'no')"
            exit 1
          fi
          
          # Exchange GitHub OIDC token for HCP access token using workload identity provider
          log_info "Exchanging GitHub OIDC token for HCP access token via workload identity provider..."
          log_info "Workload identity provider URL: $WIP_URL"
          
          TOKEN_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$WIP_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
            -d "subject_token=$GITHUB_OIDC_TOKEN" \
            -d "subject_token_type=urn:ietf:params:oauth:token-type:jwt" \
            -d "requested_token_type=urn:ietf:params:oauth:token-type:access_token" 2>&1)
          
          HTTP_CODE=$(echo "$TOKEN_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$TOKEN_RESPONSE" | sed '$d')
          
          if [ -z "$HTTP_CODE" ] || [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            log_error "Token exchange failed with HTTP $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          HCP_ACCESS_TOKEN=$(echo "$RESPONSE_BODY" | jq -r '.access_token // empty' 2>/dev/null)
          
          if [ -z "$HCP_ACCESS_TOKEN" ] || [ "$HCP_ACCESS_TOKEN" = "null" ]; then
            log_error "Failed to extract access_token from token exchange response"
            log_error "HTTP Code: $HTTP_CODE"
            log_error "Response body: $RESPONSE_BODY"
            exit 1
          fi
          
          log_info "Successfully obtained HCP access token"
          
          # Get organization ID using HCP CLI (service principals can list their orgs)
          ORG_JSON_OUTPUT=$(hcp organizations list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp organizations list'"
            log_error "Command output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_ORG_ID=$(echo "$ORG_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_ORG_ID" ] || [ "$HCP_ORG_ID" = "null" ]; then
            log_error "Failed to extract organization ID from 'hcp organizations list --format=json'."
            log_error "Raw JSON output: $ORG_JSON_OUTPUT"
            exit 1
          fi
          
          # Org ID and Project ID are identifiers, not secrets - safe to log for debugging
          log_info "Organization ID: $HCP_ORG_ID"
          
          # Get project ID using HCP CLI (service principal context already has org set, so this works directly)
          PROJECT_JSON_OUTPUT=$(hcp projects list --format=json 2>&1)
          if [ $? -ne 0 ]; then
            log_error "Failed to run 'hcp projects list'"
            log_error "Command output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          # Parse JSON array: [{"id": "...", ...}]
          HCP_PROJECT_ID=$(echo "$PROJECT_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
          
          if [ -z "$HCP_PROJECT_ID" ] || [ "$HCP_PROJECT_ID" = "null" ]; then
            log_error "Failed to extract project ID from 'hcp projects list --format=json'."
            log_error "Raw JSON output: $PROJECT_JSON_OUTPUT"
            exit 1
          fi
          
          log_info "Project ID: $HCP_PROJECT_ID"
          
          # Assign iteration to channel via HCP Packer API (PATCH method per API spec)
          # Endpoint: /organizations/{org_id}/projects/{project_id}/images/{bucket_name}/channels/{channel_name}
          HCP_BASE_URL="https://api.cloud.hashicorp.com/packer/2021-04-30"
          CHANNEL_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
            "${HCP_BASE_URL}/organizations/${HCP_ORG_ID}/projects/${HCP_PROJECT_ID}/images/homelab-infrastructure-talos/channels/aws-prod-amd64" \
            --header "Authorization: Bearer ${HCP_ACCESS_TOKEN}" \
            --header "Content-Type: application/json" \
            --data "{\"iteration_id\": \"$ITERATION_ID\"}")
          
          HTTP_CODE=$(echo "$CHANNEL_RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$CHANNEL_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "204" ]; then
            log_error "Failed to assign iteration to channel. HTTP $HTTP_CODE: $RESPONSE_BODY"
            exit 1
          fi
          
          log_success "Image promoted to aws-prod-amd64 channel."