name: 'Promote Packer Image to Channel'
description: 'Promotes a Packer image iteration to an HCP Packer channel'
inputs:
  hcp_cred_file:
    description: 'Path to HCP credential file'
    required: true
  hcp_cli_version:
    description: 'HCP CLI version'
    required: true
  iteration_id:
    description: 'Packer iteration ID to promote'
    required: true
  channel:
    description: 'HCP Packer channel name to promote to'
    required: true
  bucket_name:
    description: 'HCP Packer bucket name'
    required: true
    default: 'homelab-infrastructure-talos'
runs:
  using: 'composite'
  steps:
    - name: Setup Logging Script
      uses: ./.github/actions/setup-logging

    - name: Install HCP CLI
      uses: hashicorp/hcp-setup-action@v0.1.0
      with:
        version: ${{ inputs.hcp_cli_version }}

    - name: Promote Image to Channel
      shell: bash
      env:
        HCP_CRED_FILE: ${{ inputs.hcp_cred_file }}
        ITERATION_ID: ${{ inputs.iteration_id }}
        CHANNEL: ${{ inputs.channel }}
        BUCKET_NAME: ${{ inputs.bucket_name }}
      run: |
        source $GITHUB_WORKSPACE/logging.sh

        log_info "Promoting image to $CHANNEL channel..."
        WIP_CONFIG=$(jq -c '.workload.url // empty' "$HCP_CRED_FILE" 2>/dev/null)
        [ -z "$WIP_CONFIG" ] || [ "$WIP_CONFIG" = "null" ] && { log_error "Failed to extract workload identity provider configuration"; exit 1; }
        
        WIP_URL=$(echo "$WIP_CONFIG" | jq -r '.url // empty' 2>/dev/null)
        WIP_HEADERS=$(echo "$WIP_CONFIG" | jq -r '.headers // empty' 2>/dev/null)
        [ -z "$WIP_URL" ] || [ "$WIP_URL" = "null" ] || [ "$WIP_URL" = "" ] && { log_error "Failed to extract URL from workload identity provider configuration"; exit 1; }
        [[ ! "$WIP_URL" =~ ^https?:// ]] && { log_error "Invalid workload identity provider URL format"; exit 1; }

        log_info "Requesting GitHub OIDC token..."
        if [[ "$ACTIONS_ID_TOKEN_REQUEST_URL" == *"?"* ]]; then
          OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://auth.hashicorp.com"
        else
          OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}?audience=https://auth.hashicorp.com"
        fi
        GITHUB_OIDC_TOKEN=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" "$OIDC_REQUEST_URL" | jq -r '.value // empty' 2>/dev/null)
        [ -z "$GITHUB_OIDC_TOKEN" ] || [ "$GITHUB_OIDC_TOKEN" = "null" ] && { log_error "Failed to obtain GitHub OIDC token"; exit 1; }

        log_info "Exchanging GitHub OIDC token for HCP access token via workload identity provider..."
        
        # Validate URL format
        if [[ ! "$WIP_URL" =~ ^https:// ]]; then
          log_error "WIP URL must use HTTPS protocol"
          exit 1
        fi
        
        # Extract domain for safe logging (no query params, no paths)
        WIP_DOMAIN=$(echo "$WIP_URL" | sed -E 's|^https?://([^/]+).*|\1|')
        log_info "WIP endpoint domain: $WIP_DOMAIN"
        
        # Count headers for debugging (safe)
        HEADER_COUNT=1  # Content-Type
        if [ -n "$WIP_HEADERS" ] && [ "$WIP_HEADERS" != "null" ]; then
          CUSTOM_HEADER_COUNT=$(echo "$WIP_HEADERS" | jq -r 'to_entries | length' 2>/dev/null || echo "0")
          HEADER_COUNT=$((HEADER_COUNT + CUSTOM_HEADER_COUNT))
        fi
        log_info "Total request headers: $HEADER_COUNT"
        
        CURL_HEADERS=(-H "Content-Type: application/x-www-form-urlencoded")
        [ -n "$WIP_HEADERS" ] && [ "$WIP_HEADERS" != "null" ] && while IFS= read -r header_line; do
          [ -n "$header_line" ] && key=$(echo "$header_line" | cut -d':' -f1 | xargs) && value=$(echo "$header_line" | cut -d':' -f2- | xargs) && [ -n "$key" ] && [ -n "$value" ] && CURL_HEADERS+=(-H "${key}: ${value}")
        done < <(echo "$WIP_HEADERS" | jq -r 'to_entries[] | "\(.key): \(.value)"' 2>/dev/null || echo "")

        # Capture stderr and stdout separately for diagnostic info
        CURL_STDERR=$(mktemp)
        CURL_STDOUT=$(mktemp)
        
        log_info "Making token exchange POST request..."
        # Exit code 5 typically means "Couldn't resolve proxy" - disable proxy to avoid this
        curl -w "\n%{http_code}" -X POST "$WIP_URL" "${CURL_HEADERS[@]}" \
          -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
          -d "subject_token=$GITHUB_OIDC_TOKEN" \
          -d "subject_token_type=urn:ietf:params:oauth:token-type:jwt" \
          -d "requested_token_type=urn:ietf:params:oauth:token-type:access_token" \
          --max-time 30 \
          --connect-timeout 10 \
          --noproxy "*" \
          -o "$CURL_STDOUT" 2>"$CURL_STDERR"
        CURL_EXIT_CODE=$?
        TOKEN_RESPONSE=$(cat "$CURL_STDOUT" 2>/dev/null || echo "")
        CURL_ERROR=$(cat "$CURL_STDERR" 2>/dev/null || echo "")
        rm -f "$CURL_STDERR" "$CURL_STDOUT"
        
        if [ $CURL_EXIT_CODE != 0 ]; then
          log_error "Token exchange request failed with curl exit code $CURL_EXIT_CODE"
          if [ -n "$CURL_ERROR" ]; then
            # Log curl error messages (usually safe - they're about DNS, SSL, etc., not tokens)
            SANITIZED_ERROR=$(echo "$CURL_ERROR" | head -c 500 | tr -d '\n\r' | sed 's/[^[:print:]]/ /g')
            log_error "Curl error details: $SANITIZED_ERROR"
          else
            log_error "No curl error message captured (stderr was empty)"
          fi
          if [ -n "$TOKEN_RESPONSE" ]; then
            HTTP_CODE_CHECK=$(echo "$TOKEN_RESPONSE" | tail -n 1)
            log_error "Response HTTP code: $HTTP_CODE_CHECK"
          fi
          log_error "Failed to reach WIP endpoint at domain: $WIP_DOMAIN"
          log_error "URL format validated: HTTPS protocol confirmed"
          log_error "Headers configured: $HEADER_COUNT headers total"
          exit 1
        fi
        
        HTTP_CODE=$(echo "$TOKEN_RESPONSE" | tail -n 1)
        RESPONSE_BODY=$(echo "$TOKEN_RESPONSE" | sed '$d')
        [ -z "$HTTP_CODE" ] || [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ] && { log_error "Token exchange failed with HTTP $HTTP_CODE"; exit 1; }

        RESPONSE_KEYS=$(echo "$RESPONSE_BODY" | jq -r 'keys | join(", ")' 2>/dev/null || echo "not JSON")
        HCP_ACCESS_TOKEN=$(echo "$RESPONSE_BODY" | jq -r '.access_token // .token // .accessToken // .value.access_token // .value.token // empty' 2>/dev/null)
        [ -z "$HCP_ACCESS_TOKEN" ] || [ "$HCP_ACCESS_TOKEN" = "null" ] && { log_error "Failed to extract access_token from token exchange response. HTTP Code: $HTTP_CODE. Response contains keys: $RESPONSE_KEYS"; exit 1; }
        log_info "Successfully obtained HCP access token"

        log_info "Authenticating HCP CLI..."
        hcp auth login --cred-file="$HCP_CRED_FILE" || { log_error "Failed to authenticate HCP CLI"; exit 1; }
        log_success "HCP CLI authenticated successfully."

        log_info "Fetching organization ID..."
        ORG_JSON_OUTPUT=$(hcp organizations list --format=json 2>&1) || { log_error "Failed to run 'hcp organizations list'"; exit 1; }
        HCP_ORG_ID=$(echo "$ORG_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
        [ -z "$HCP_ORG_ID" ] || [ "$HCP_ORG_ID" = "null" ] && { log_error "Failed to extract organization ID"; exit 1; }
        log_info "Organization ID: $HCP_ORG_ID"

        log_info "Fetching project ID..."
        PROJECT_JSON_OUTPUT=$(hcp projects list --format=json 2>&1) || { log_error "Failed to run 'hcp projects list'"; exit 1; }
        HCP_PROJECT_ID=$(echo "$PROJECT_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
        [ -z "$HCP_PROJECT_ID" ] || [ "$HCP_PROJECT_ID" = "null" ] && { log_error "Failed to extract project ID"; exit 1; }
        log_info "Project ID: $HCP_PROJECT_ID"

        log_info "Promoting iteration $ITERATION_ID to channel $CHANNEL..."
        CHANNEL_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
          "https://api.cloud.hashicorp.com/packer/2021-04-30/organizations/${HCP_ORG_ID}/projects/${HCP_PROJECT_ID}/images/${BUCKET_NAME}/channels/${CHANNEL}" \
          --header "Authorization: Bearer ${HCP_ACCESS_TOKEN}" \
          --header "Content-Type: application/json" \
          --data "{\"iteration_id\": \"$ITERATION_ID\"}")
        
        HTTP_CODE=$(echo "$CHANNEL_RESPONSE" | tail -n 1)
        [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "204" ] && { log_error "Failed to assign iteration to channel. HTTP $HTTP_CODE"; exit 1; }
        log_success "Image promoted to $CHANNEL channel."

